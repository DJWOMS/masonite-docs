# Service Container

Сервисный контейнер — чрезвычайно мощная функция Masonite и его следует использовать в максимально 
широко. Важно понимать концепции Сервисного контейнера. Это простые концепции, которые, тем не менее, 
могут показаться волшебными, если вы не понимаете, что происходит под капотом.

## Начало

Сервисный контейнер — это просто словарь, в который записаны классы в виде пар ключ-значение. 
Затем они могут быть извлечены либо по ключу, либо по значению через определяемые объекты.

Думайте об "определяемых объектах" в соответствии с утверждением Masonite: 
"Что нужно вашему объекту? Ок, они есть в этом словаре, позвольте мне достать их для вас".

Контейнер содержит все классы и возможности фреймворка, так что добавление функционала в Masonite 
только добавляет классы в контейнер для использования разработчиком позже. Обычно это означает 
"регистрация" этих классов в контейнере (подробнее об этом позже). Это позволяет Masonite быть модульным.

Некоторые объекты определены в контейнере по умолчанию. К ним относятся ваши методы контроллера 
(которые встречаются наиболее часто и вы, вероятно, использовали их ранее), конструкторы драйверов и 
middleware. И любые другие классы которые указаны в документации.

Есть 3 метода, которые важны во взаимодействии с контейнером: `bind`, `make` и `resolve`. 

## Bind 

Для связывания классов внутри контейнера следует использовать метод `bind` в нашем приложении. 
В service provider это будет выглядеть следующим образом:
```py
from masonite.provider import ServiceProvider

from app.User import User


class UserModelProvider(ServiceProvider):

    def register(self):
        self.application.bind('User', User)

    def boot(self):
        pass
```


Это загрузит пары ключ - значение в словарь providers в контейнере. После этого вызова словарь будет 
выглядеть так:
```jupyter
>>> app.providers

{'User': <class app.User.User>}
```

Сервисный контейнер доступен в объекте Request и может быть получен так:
```py
def show(self, request: Request):
    request.app() # вернет service container
```

## Simple Binding 

Иногда не важно, какой ключ у объекта, который вы связываете. Например, вы можете привязать класс 
Markdown к контейнеру, но на самом деле все равно, как называется связанный ключ. 
Это отличная причина использовать простую привязку, которая установит ключ как объект класса:
```py
from masonite.provider import ServiceProvider

from app.User import User


class UserModelProvider(ServiceProvider):

    def register(self):
        self.application.simple(User)

    def boot(self):
        pass
```

## Make

Для того чтобы получить класс из сервисного контейнера, мы можем просто использовать метод make.
```jupyter
>>> from app.User import User

>>> app.bind('User', User)

>>> app.make('User')

<class app.User.User>
```
Вот оно! Это полезно в качестве IOC (инверсия управления) контейнера, который вы можете 
загрузить отдельным классом в контейнер и потом использовать его повсюду в вашем проекте. 

## Singleton

Вы можете привязывать singleton к контейнеру. Это определит объект во время привязки. 
Это позволит использовать один и тот же объект на протяжении всего срока службы контейнера.
```py
from masonite.provider import ServiceProvider

from app.helpers import SomeClass


class UserModelProvider(ServiceProvider):

    def register(self):
        self.application.singleton('SomeClass', SomeClass)

    def boot(self):
        pass
```

## Has

Вы можете также проверить, существует ли ключ в контейнере, используя метод `.has()`:
```py
app.has('request')
```
Вы можете также проверить, существует ли ключ в контейнере, используя ключевое слово `in`:
```py
'request' in app
```
## Collecting (Группировка)

Вам может понадобиться собрать специфический набор объектов из контейнера по какому-то ключу. 
Например, могут понадобиться все объекты, которые начинаются с "Exception" и заканчиваются "Hook". 
Или все ключи, которые заканчиваются на "ExceptionHook", если мы создаём обработчик исключений.

### Collect by Key (Группировка по ключу)

Мы можем легко собрать все объекты по ключу:
```py
app.collect('*ExceptionHook')
```
Это вернет словарь всех объектов, связаные с контейнером, которые начинаются с чего угодно и 
заканчиваются на "ExceptionHook", такие как "SentryExceptionHook" или "AwesomeExceptionHook".

Мы также можем сделать противоположное и собрать все объекты, которые начинаются со специфического ключа.
```py
app.collect('Sentry*')
```
Будт собраны все ключи, которые начинаются с "Sentry", такие как "SentryWebhook" или 
"SentryExceptionHandler".

Наконец, мы можем собрать объекты, которые начинаются с "Sentry" заканчиваются на "Hook".
```py
app.collect('Sentry*Hook')
```
Мы получим такие ключи как "SentryExceptionHook" и "SentryHandlerHook"

## Collecting By Object (Группировка по объекту)

Вы можете также собрать все подклассы объекта или если хотите собрать все сущности специфического
 класса из контейнера.
```py
from cleo import Command

...

app.collect(Command)

# Returns {'FirstCommand': <class ...>, 'AnotherCommand': ...}
```

## Resolve (Определение)

Это наиболее мощная часть контейнера. Можно получить объекты из контейнера просто передав их в список 
параметров любого объекта. Некоторые области Masonite определены, такие как, методы контроллера, middleware и 
drivers.

Например, мы хотим получить класс Request и поместить его в наш контроллер. Все методы контроллера 
определены контейнером.
```py
def show(self, request: Request):
    request.user()
```
В этом примере, перед тем как показать что метод вызван, Masonite посмотрит на параметры и посмотрит 
внутрь контейнера в поисках объекта Request.

Masonite будет знать, что вы пытаетесь получить класс Request и фактически извлечёт этот класс из 
контейнера. Masonite найдет класс Request несмотря на то, какой ключ в контейнере, вернёт его, и 
поместит их в метод контроллера. Эффективное создание IOC контейнера с dependency injection. 
Думайте об этом как о **get by value** или **get by key** в примерах ранее. 

Очень мощная штука, да?

Masonite также будет определять ваш пользовательский, **специфичный для приложения класс, включая те, 
которые вы явно не связываете с помощью `app.bind()`**

Продолжая пример выше, следующее будет работать из коробки (при условии, что соответствующие классы 
существуют), без необходимости связывать пользовательские классы в контейнере:
```py
# в другом месте...

class MyService:
    def __init__(self, some_other_dependency: SomeOtherClass):
        pass
    
    def do_something(self):
        pass


# в контроллере...
def show(self, request: Request, service: MyService):
    request.user()
    service.do_something()
```
## Resolving Instances (Определение сущностей)

Следующая мощная особенность контейнера заключается в том, что он может фактически вернуть сущности 
классов, которые вы упоминаете. Например, все драйверы `Upload` наследуются от `UploadContract`, 
который работает как интерфейс для всех `Upload` драйверов. Множество парадигм программирования 
утверждают, что разработчики должны создавать интерфейс, а не реализацию, так что Masonite позволяет 
возвращать сущности классов для этого специфического случая использования.

Держите пример:
```py
from masonite.contracts import UploadContract


def show(self, upload: UploadContract)
    upload # <class masonite.drivers.UploadDiskDriver>
```

Обратите внимание, что мы передали контракт вместо класса Upload. 

## Resolving your own code (Определение вашего собственного кода)

Сервисный контейнер также может быть использован вне потока Masonite. Masonite принимает функцию или метод класса, и определяет их зависимости путём нахождения их в сервисном контейнере и внедряя их для вас.

Благодаря этому, вы можете определить любой собственный класс или функцию.

*from masonite.request import Request*

*from masonite.view import View*

*def randomFunction(view: View):*

`    `*print(view)*

*def show(self, request: Request):*

`    `*request.app().resolve(randomFunction) # Will print the View object*

Помните, что вам не следует вызывать его, а только сослаться на функцию. Сервисный контейнер должен внедрять зависимости в объект, поэтому он требует ссылку а не вызов.

Это позволит получить все параметры randomFunction и извлечь их из сервисного контейнера. Возможно, вам нечасто придётся регистрировать ваш собственный код, но такая возможность имеется.

## Resolving With Additional Parameters (Определение с дополнительными параметрами)

Иногда может понадобиться определить ваш код в дополнение к передаче переменных в том же списке параметров. Например, если вам нужно 3 параметра наподобие этих:

*from masonite.request import Request*

*from masonite import Mail*

*def send_email(request: Request, mail: Mail, email):*

`    `*pass*

Вы можете зарегистрировать и передать параметр одновременно, добавив их в resolve() метод:

*app.resolve(send_email, 'user@email.com')*

Masonite просматривает каждый список параметров и определяет их, а если он не находит параметр, он получит его из других указанных параметров. Эти параметры могут идти в любом порядке.

## Using the container outside of Masonite flow (Использование контейнера за пределами потока Masonite)

Если вам нужно использовать контейнер за пределами нормального потока Masonite, например внутри команды, вы можете импортировать контейнер напрямую.

Это будет выглядеть следующим образом:

*from wsgi import container*

*from masonite import Queue*

*class SomeCommand:*

`    `*def handle(self):*

`        `*queue = container.make(Queue)*

`        `*queue.push(..)*

## Container Swapping (Замена контейнера)

Иногда, когда вы регистрируете объект или класс, вы хотите, чтобы возвращалось другое значение.

### Using a value (Использование значения)

Мы можем передать простое значение как второй параметр в swap метод, который будет возвращён вместо определяемого объекта. Например, это используется сейчас для определения класса Mail следующим образом:

*from masonite import Mail*

*def show(self, mail: Mail):*

`    `*mail #== <masonite.drivers.MailSmtpDriver>*

Но определение класса для класса Mail здесь выглядит так:

*class Mail:*

`    `*pass*

Откуда он знает, что вместо этого нужно зарегистрировать smpt драйвер? Это происходит, потому что добавлен swap контейнера. Swap контейнера работает просто - он может взять объект как первый параметр и либо значение, либо вызываемый объект в качестве второго.

Например, чтобы сымитировать вышеуказанную функциональность, выполним что-то вроде этого в методе загрузки в Service Provider:

*from masonite import Mail*

*def boot(self, mail: MailManager):*

`    `*self.application.swap(Mail, manager.driver(self.application.make('MailConfig').DRIVER))*

Обратите внимание, что мы указали класс, который должен быть возвращён каждый раз, когда мы определяем класс Mail. В этом случае мы хотим разрешить драйвер по умолчанию, определённый в конфигурации проекта.


### Using a callable (Использование вызываемого объекта)

Вместо прямой передачи значения как второго параметра мы можем вместо этого передать вызываемый объект. Вызываемый объект ДОЛЖЕН получить 2 параметра. Первым параметром будет аннотация, которую мы пытаемся определить, а вторым параметром будет сам контейнер. Вот пример, как вышеизложенное будет работать с вызываемым объектом:

*from masonite import Mail*

*from somewhere import NewObject*

*...*

*def mail_callback(obj, container):*

`    `*return NewObject*

*...*

*def boot(self):*

`    `*self.application.swap(Mail, mail_callback)*

Обратите внимание, что вторым параметром является вызываемый объект. Это значит, что он будет вызван 
каждый раз, когда мы пытаемся определить класс Mail.

Запомните: если второй параметр это вызываемый объект, он будет вызван. Если это значение, оно будет 
просто возращено вместо определяемого объекта.


## Container Hooks (Связи контейнера)

Иногда нам хочется запустить код, когда что-то происходит внутри нашего контейнера. Например, мы хотим 
запустить некоторую произвольную функцию для определения  объекта Request из контейнера или мы хотим 
привязать некоторые значения к классу View всякий раз, когда мы связываем Response с контейнером. 
Это отлично подходит для тестирования, если мы хотим привязать пользовательский объект к запросу 
каждый раз, когда он определяется. 

У нас есть три варианта: on_bind, on_make, on_resolve. Все, что нам нужно для первого варианта это 
ключ или объект, к которому мы хотим привязаться, и второй вариант будет функцией, которая принимает 
два аргумента. Первый аргумент это объект в вопросе, а второй аргумент это весь контейнер.

Код может выглядеть следующим образом:

*from masonite.request import Request*

*def attribute_on_make(request_obj, container):*

`    `*request_obj.attribute = 'some value'*

*...*

*container = App()*

*# sets the hook*

*container.on_make('request', attribute_on_make)*

*container.bind('request', Request)*

*# runs the attribute_on_make function*

*request = container.make('request')*

*request.attribute # 'some value'*

Заметим, что мы создаём функцию, которая принимает 2 значения, объект, с которым мы работаем, и контейнер. Каждый раз, когда мы запускаем on\_make, функция запускается. 

Мы также можем привязываться к конкретным объектам вместо ключей:

*from masonite.request import Request*

*# ...*

*# sets the hook*

*container.on_make(Request, attribute_on_make)*

*container.bind('request', Request)*

*# runs the attribute_on_make function*

*request = container.make('request')*

*request.attribute # 'some value'*

После этого он вызывает тот же атрибут, но каждый раз объект Request сам создаётся из контейнера. Заметьте, что все идентично, кроме строки 6, где мы используем объект вместо строки. 

Мы можем делать то же самое с другими вариантами:

*container.on_bind(Request, attribute_on_make)*

*container.on_make(Request, attribute_on_make)*

*container.on_resolve(Request, attribute_on_make)*
